---
title: "Geospatial Analysis of Dry Season Environmnetal Drivers of Malaria Cases in Kasungu"
output: 
  html_document: 
    toc: yes
    toc_float: yes
    number_sections: yes
    code_download: true
latex_engine: MiKTeX
author: Clinton Nkolokosa
date: " Last edited `r format(Sys.time(),'%d %B %Y')`"
---

This geospatial statistical model uses routinely collected malaria case data, population data and remotely sensed data, such as open and vegetated water bodies, to estimate population living around open water bodies, expected malaria cases, and `standardised morbidity ratio` (`SMR`) of malaria. And ultimately, quantify the association between proximity to larval habitat and malaria risk in health facility catchment areas in Kasungu. The `SMR` compares the risk of morbidity in a population of interest with that of a standard population. In this case, our interest is to find out whether the number of dry season malaria cases in each catchment area are greater than we would expect given the malaria rate for the entire Kasungu district.

We do this by comparing what we *observe* (O) with what we would *expect* (E) if the risk of malaria was equal throughout Kasungu. The SMR statistical notation of catchment *i* can be written as follows: $$SMR_i = \frac{O_i}{E_i}$$

Buffers around waterbodies are created and then combined with population data in raster format to estimate the proprtion of catcment population living within 1km, 2km and 3km of water bodies. Subsequently, the observed malaria cases are modeled using `Poisson regression` to find out if living within various distances from water bodies is causing variability in malaria risk in Kasungu district. We hypothesize that the risk of being a case in a catchment is dependent on proximity to water bodies. The data used spans from 2017 to 2020 and was derived from digitized DHIS2 malaria records, accessibility mapping, aggregated population geospatial layer and TropWet tool in Google Earth Engine.

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center', echo = TRUE)

# thematic::thematic_rmd()

```

# Load packages

Loading the R packages that will be used to read in, view, transform and model the malaria cases and spatial datasets.

```{r, warning = FALSE, message = FALSE}
suppressPackageStartupMessages({
  library(SpatialEpi)
  library(spdep)
  library(spaMM)
  library(popEpi)
  library(Epi)
  library(epitools)      # compute confidence intervals of malaria data
  library(tidyverse)
  library(caret)         # easily compute cross-validation methods to test model performance
  library(stats)
  library(MASS)          # fit negative binomial model
  library(performance)   # check linear model performance
  library(see)           # to plot model assumptions
  library(caTools)       # splitting data into training and test data sets
  library(glmmTMB)       # check overdispersion
  library(lme4)          # fit GLM
  library(report)        # automatically produce regression model reports
  library(qqplotr)
  library(DescTools)     # tools for descriptive statistics e.g., pseudo R-squared
  library(gtsummary)     # easily display regression model outputs, such as P value, CI
  library(ggpubr)
  library(plotly)
  library(lubridate)
  library(knitr)
  library(raster)
  library(rgdal)
  library(rgeos)
  library(readr)
  library(sf)
  library(sp)
  library(tmap)
  library(spdep)
  library(maptools)
  library(gridExtra)
  library(ggsci)
  library(grid)
  library(exactextractr)
  library(DataExplorer)
  library(thematic)
  library(mapview)
  library(kableExtra)    # create interactive tables
  library(gt)            # create beautiful HTML tables
  library(pander)        # improves the aesthetics of R outputs
  library(imputeTS)      # easily remove NAs
  `%>%` <- magrittr::`%>%`

})
```

## Tell R where the data is

```{r}
file.path(getwd(),"data")

here::here()
```



# Load datasets

The total dry season malaria cases recorded at health-care facilities in Kasungu from 2017 to 2019 are contained in the `KasunguData.csv` sourced from <https://dhis2.health.gov.mw/>. The `kasungu_facility_catchments_2004.shp` shapefile also contains the population and health information within each health-facility catchment area in Kasungu district.

The aggregated population raster layers for Malawi e.g.,`ku_pop_2017_1km_aggregated.tif` were downloaded from the Open Spatial and Demographic and Data Research website: <https://www.worldpop.org/geodata/country?iso3=MWI>. These layers estimate total number of people per grid-cell. The units are number of people per pixel with country totals adjusted to match the corresponding official United Nations population estimates. The datasets were downloaded in Geotiff at a resolution of 1km and are projected in Geographic Coordinate System, WGS84.

The `kasungu_water.shp`and `water_bodies` layers contain open and vegetated waterbodies polygons, detected using the Tropical Wetland Unmixing Tool (TropWet). TropWet is a Google Earth Engine hosted toolbox that uses the Landsat archive to map tropical wetlands and can be accessed through: <https://www.aber.ac.uk/en/dges/research/earth-observation-laboratory/research/tropwet/>

```{r, Kasungu water bodies polygons, malaria cases by health facility catchments and population layers, message= FALSE, results='hide'}

# Kasungu dry season malaria data
dry_season_malaria_2017_2020 <- read.csv(here::here("data/dry_season_malaria_2017_2020.csv"),
                                         stringsAsFactors = FALSE)

# Kasungu monthly NMCP confirmed malaria cases
monthly_malaria_2017_2021 <- read.csv(here::here("data/Kasungu monthly malaria 2017-2021.csv"),
                                      stringsAsFactors = FALSE)

monthly_malaria_2017_2021$date <- lubridate::ym(monthly_malaria_2017_2021$periodid) 

# Kasungu district boundary shapefile 
kasungu_district <- sf::st_read(here::here("data", "kasungu_district.shp"))
  
# Kasungu health facility catchments generated from accessibility mapping
malire_new <- sf::st_read(here::here("data", "zipatala_catchment_areas.shp")) |> 
              sf::st_transform(32736) # reproject to WGS UTM Zone 36 South

# Aggregated health-facilities
zipatala_aggregated_sf <- sf::st_read(here::here("data", "zipatala_combined.shp"))

# Kasungu population raster layer
kasungu_population_2017 <- raster(here::here("data", "ku_pop_2017_1km_aggregated.tif"))

kasungu_population_2018 <- raster(here::here("data", "ku_pop_2018_1km_aggregated.tif"))

kasungu_population_2019 <- raster(here::here("data", "ku_pop_2019_1km_aggregated.tif"))

kasungu_population_2020 <- raster(here::here("data", "ku_pop_2020_1km_aggregated.tif"))

# TropWet derived dry season waterbody polygons.  
# See Kasungu_malaria_RMD on how the buffers were generated
buffer_1km_2017 <- sf::st_read(here::here("data", "buffer_1km_2017.shp"))

buffer_2km_2017 <- sf::st_read(here::here("data", "buffer_2km_2017.shp"))

buffer_3km_2017 <- sf::st_read(here::here("data", "buffer_3km_2017.shp"))

buffer_1km_2018 <- sf::st_read(here::here("data", "buffer_1km_2018.shp"))

buffer_2km_2018 <- sf::st_read(here::here("data", "buffer_2km_2018.shp"))

buffer_3km_2018 <- sf::st_read(here::here("data", "buffer_3km_2018.shp"))

buffer_1km_2019 <- sf::st_read(here::here("data", "buffer_1km_2019.shp"))

buffer_2km_2019 <- sf::st_read(here::here("data", "buffer_2km_2019.shp"))

buffer_3km_2019 <- sf::st_read(here::here("data", "buffer_3km_2019.shp"))

buffer_1km_2020 <- sf::st_read(here::here("data", "buffer_1km_2020.shp"))

buffer_2km_2020 <- sf::st_read(here::here("data", "buffer_2km_2020.shp"))

buffer_3km_2020 <- sf::st_read(here::here("data", "buffer_2km_2020.shp"))

```

## Waterbody buffers by catchment map
Note that blank areas in the map represent catchment areas in which no water body was detected — this may be a limitation of using moderate resolution satellite imagery (>30m spatial resolution) to identify surface water.

```{r, fig.height=9, fig.width=10, fig.cap='Fig 9. Buffers around dry season waterbodies in Kasungu'}

# Map the buffers
create.buffer.map <- function(buffers, boundary = malire_new, title = NA){
  # function for creating buffer map in ggplot
  # arguments:
  #   buffer:  waterbodies buffer polygon layer
  #   boundary: health facility catchment polygons
  #   title: main title
  # returns:
  #   a map-element (plots a map)
  ggplot(data = buffers)+
     geom_sf()+
     geom_sf(data = boundary, 
             fill = NA)+
     theme_void()+
     labs(title = title)
}

# Invoking the function
# For 2017 -------------------------------------------------------------------------------
buffer_1km_2017_map <- create.buffer.map(buffer_1km_2017, title = "2017: 1km Buffers")

buffer_2km_2017_map <- create.buffer.map(buffer_2km_2017, title = "2017: 2km Buffers")

buffer_3km_2017_map <- create.buffer.map(buffer_3km_2017, title = "2017: 3km Buffers")

# For 2018 --------------------------------------------------------------------------------
buffer_1km_2018_map <- create.buffer.map(buffer_1km_2018, title = "2018: 1km Buffers")

buffer_2km_2018_map <- create.buffer.map(buffer_2km_2018, title = "2018: 2km Buffers")

buffer_3km_2018_map <- create.buffer.map(buffer_3km_2018, title = "2018: 3km Buffers")

# For 2019 ---------------------------------------------------------------------------------
buffer_1km_2019_map <- create.buffer.map(buffer_1km_2019, title = "2019: 1km Buffers")

buffer_2km_2019_map <- create.buffer.map(buffer_2km_2019, title = "2019: 2km Buffers")

buffer_3km_2019_map <- create.buffer.map(buffer_3km_2019, title = "2019: 3km Buffers")

# For 2020 --------------------------------------------------------------------------------
buffer_1km_2020_map <- create.buffer.map(buffer_1km_2020, title = "2020: 1km Buffers")

buffer_2km_2020_map <- create.buffer.map(buffer_2km_2020, title = "2020: 2km Buffers")

buffer_3km_2020_map <- create.buffer.map(buffer_3km_2020, title = "2020: 3km Buffers")
 
grid.arrange(buffer_1km_2017_map, buffer_1km_2018_map, buffer_1km_2019_map, buffer_1km_2020_map,
             buffer_2km_2017_map, buffer_2km_2018_map, buffer_2km_2019_map, buffer_2km_2020_map, 
             buffer_3km_2017_map, buffer_3km_2018_map, buffer_3km_2019_map, buffer_3km_2020_map, ncol = 4)


```

# Standardised Morbidity Ratio of dry season malaria cases in Kasungu

## Generate health-facility catchment areas

First, in order to calculate the `SMR` of dry season malaria cases for each health-facility catchment area, we need to generate the catchment areas. Heath facility catchment area is the area from which a health facility attracts patients. Since the available official catchment areas are outdated and no recent spatial data about the catchment areas is available, new health facility catchments polygon were generated from generic accessibility mapping script adapted from <https://malariaatlas.org/wp-content/uploads/accessibility/R_generic_accessibilty_mapping_script.r> The script requires two user supplied datasets: the `2015 friction surface`, which is available here: <http://www.map.ox.ac.uk/accessibility_to_cities/>, and a user-supplied .csv of points `dry_season_malaria_2017_2020`. The accumulated cost algorithm `accCost` and `r.Cost` algorithm were run in R and QGIS, respectively, to make the final output map of new health facility catchment boundaries.

```{r, warning = FALSE, message = FALSE, fig.cap='Fig 1. Kasungu health-care facilities and catchment areas'}

# Plot map
tm_shape(malire_new)+
  tm_polygons()+
  tm_shape(zipatala_aggregated_sf)+
  tm_dots(size = .3, 
          col = "blue", 
          alpha = 0.5)+
  tm_text("Names", 
          size = .3, 
          just = "top", 
          col = "black", 
          remove.overlap = TRUE)+
  tm_layout(frame = FALSE,
            title = "New Kasungu health facility \n catchment boundaries",
            title.size = .8, 
            title.position = c("left", "top"))+
  tm_compass(position=c("right", "top"))+
  tm_scale_bar(breaks = c(0, 10, 20), 
               text.size = .5)


```

## Assign dry season malaria cases and population density to new health facility catchments

The WorldPop `aggregated population` e.g. `kasungu_population_2017.tif`, and DHIS2 malaria `dry_season_malaria_2017_2020` datasets are assigned to the new health facility catchments.

```{r, message=FALSE, warning=FALSE}
# Helper function that assigns malaria data from health facilities to their catchments areas 
assign.malaria.data <- function(catchment_boundary, malaria_data){
  # arguments:
  #   catchment_boundary: sf polygon object of new catchment boundaries
  #   malaria_data: sf point object with a data frame containing the dry season malaria cases
  # returns:
  #   catchments_malaria_sf: sf polygon object with a data frame containing dry season malaria cases

  # Convert sf objects to spatial
  catchment_shp <- as(catchment_boundary, "Spatial")
  
  malaria_shp <- as(malaria_data, "Spatial")

  # Match CRS
  malaria_shp <- spTransform(malaria_shp, crs(catchment_shp))

  # Joining the malaria and population dataset using only 'merge' function can't work due to 
  # non-unique columns and differences in row numbers
    hospitals_in_catchment <- spatialEco::point.in.poly(malaria_shp, catchment_shp, sp = TRUE) 

  # Add the extracted ID, health facility names and dry season malaria cases to 
  # the health facility catchments (hfc)
  hfc_malaria_shp <- merge(catchment_shp, hospitals_in_catchment, by.x = "DN", by.y = "rowID")

  # Convert the shapefile containing malaria data to sf-object
  hfc_malaria_sf <- sf::st_as_sf(hfc_malaria_shp)

  # Tidy the data by dropping columns not needed
  catchment_malaria <- hfc_malaria_sf |> 
    dplyr::select(-c(coords.x1, coords.x2))

  return(out = catchment_malaria)
}

# Invoking the function --------------------------------------------------------
malaria_by_catchment <- assign.malaria.data(malire_new, zipatala_aggregated_sf)

```

## Assign population data to the health catchment areas

The population raster is a continuous gridded surface layer that has an estimated population density value to every square in their grid. The population values are extracted using `raster::extract()`, summed and apportioned to the catchment polygons.

```{r, message=FALSE}

# Helper unction to extract population from WorldPop raster file and assign
# the values to the new catchments.

extract.pop.values <- function(kasungu_pop_raster, catchments){
  # convert from sf to sp
  catchments_sp <- as(catchments, "Spatial")
  
  # Match extent i.e projection
  catchments_sp <- spTransform(catchments_sp, proj4string(kasungu_pop_raster))
  
  # Crop and mask the population raster to exclude Kasungu National Park
  pop_raster_clip <- raster::crop(kasungu_pop_raster, extent(catchments_sp)) |>
    raster::mask(catchments_sp)
  
  # Extracting zonal statistics from a population raster layer
  pop_by_catchment <- round(raster::extract(pop_raster_clip, catchments, fun = sum, na.rm = TRUE))
  
  pop_by_catchment_df <-  pop_by_catchment %>%  
  # apply unlist to the lists to have vectors as the list elements
  lapply(unlist) %>%  
  # convert vectors to data.frames
  lapply(as_tibble) %>%   
  # combine the list of data.frames
  bind_rows(., .id = "rowID") %>%   
  # rename the value variable
  dplyr::rename(pop = value)
  
  # Add row ID to column to catchment layer
  catchments$rowID <- 1:nrow(catchments)
  
  # Merge catchment areas and population data 
  pop_by_catchments <- merge(catchments, pop_by_catchment_df, by = "rowID")
  
  # Cleaning 'Inf' values
  pop_by_catchments |> 
    dplyr::mutate_if(is.numeric, list(~na_if(., Inf))) |> 
    dplyr::mutate_if(is.numeric, list(~na_if(., -Inf)))

  return(out = pop_by_catchments)
  
}

# Invoking the function -------------------------------------------------------------------------
malaria_pop_by_catchment_2017 <- extract.pop.values(kasungu_population_2017, malaria_by_catchment)

malaria_pop_by_catchment_2018 <- extract.pop.values(kasungu_population_2018, malaria_by_catchment)

malaria_pop_by_catchment_2019 <- extract.pop.values(kasungu_population_2019, malaria_by_catchment)

malaria_pop_by_catchment_2020 <- extract.pop.values(kasungu_population_2020, malaria_by_catchment)

```

## Calculate the expected number of cases for each catchment area

The `expected` number of dry season malaria cases in catchment *i* are calculated as the observed risk (r) of malaria i.e. the total number of malaria cases in Kasungu district divided by the total population of the district, multiplied by the number of people in the catchment area: $$E_i = \frac{\sum_i O_i}{\sum_i N_i}\times N_i$$

The `expected` number of dry season malaria cases are calculated under the assumption that there is no spatial variation in risk, i.e., no difference in infection rates between the catchment areas.

```{r, message=FALSE}
# Calculate expected malaria cases ------------------------------------------------
expected_malaria_2017 <- malaria_pop_by_catchment_2017 |>
  dplyr::rename(
    observed_2017 = dr_2017,
     pop_2017 = pop) |> 
  dplyr::mutate(
    expected_2017 = round(sum(observed_2017)/sum(pop_2017, na.rm = TRUE)*pop_2017))

expected_malaria_2018 <- malaria_pop_by_catchment_2018 |>
  dplyr::rename(
    observed_2018 = dr_2018,
    pop_2018 = pop) |> 
  dplyr::mutate(
    expected_2018 = round(sum(observed_2018)/sum(pop_2018, na.rm = TRUE)*pop_2018))

expected_malaria_2019 <- malaria_pop_by_catchment_2019 |>
  dplyr::rename(
    observed_2019 = dr_2019,
    pop_2019 = pop) |>
  dplyr::mutate(
    expected_2019 = round(sum(observed_2019)/sum(pop_2019, na.rm = TRUE)*pop_2019)) 

expected_malaria_2020 <- malaria_pop_by_catchment_2020 |>
  dplyr::rename(
    observed_2020 = dr_2020,
    pop_2020 = pop) |>
  dplyr::mutate(
    expected_2020 = round(sum(observed_2020)/sum(pop_2020, na.rm = TRUE)*pop_2020))

```

## Calculate the SMR of malaria incidences for each catchment area

The `SMR` compares the risk of morbidity in a population of interest with that of a standard population. In this case, our interest is to find out whether the number of dry season malaria cases in each catchment area are greater than we would expect given the malaria rate for the entire Kasungu district.

We do this by comparing what we `observe` (O) with what we would `expect` (E) if the risk of malaria was equal throughout Kasungu. The SMR of catchment *i* can be calculated as follows: $$SMR_i = \frac{O_i}{E_i}$$

SMRs above 1 represent high risk of dry season malaria and SMRs below 1, viceversa.

```{r}
# Calculate the ratio of observed to expected (SMR) ----------------------------
SMR_2017 <- expected_malaria_2017 |>
  dplyr::mutate(SMR = round(observed_2017/expected_2017, 1)) |> 
  dplyr::select(rowID,Names, pop_2017, observed_2017, expected_2017, SMR) 

SMR_2018 <- expected_malaria_2018 |> 
  dplyr::mutate(SMR = round(observed_2018/expected_2018, 1)) |> 
  dplyr::select(rowID, Names, pop_2018, observed_2018, expected_2018, SMR) 

SMR_2019 <- expected_malaria_2019 |> 
  dplyr::mutate(SMR = round(observed_2019/expected_2019, 1)) |> 
  dplyr::select(rowID, Names, pop_2019, observed_2019, expected_2019, SMR) 

SMR_2020 <- expected_malaria_2020 |> 
  dplyr::mutate(SMR = round(observed_2020/expected_2020, 1)) |> 
  dplyr::select(rowID, Names, pop_2020, observed_2020, expected_2020, SMR)

```

## SMR by catchment maps

SMRs above 1 represent high risk of dry season malaria and SMRs below 1, viceversa. A ratio greater than 1.0 indicates that more malaria cases have occurred than would have been expected, while a ratio less than 1.0 indicates that less cases have occurred. Thus, catchments with SMRs above 1 have high dry season malaria risk.

```{r, message=FALSE, fig.height = 5, fig.width = 7, fig.cap = 'Fig. 8: Standardised morbidity ratio of malaria by health facility catchment'}

# Define function to create maps of SMR by catchment ---------------------------
create.smr.map <- function(smr.data, 
                           variable = "SMR_category", 
                           title = NA, 
                           legend.title = "SMR"){
  # create category column
  smr.data$SMR_category <- NA
  
  # assigning labels for the SMR estimate legends
  smr.category.list <- c("<0.50", "0.51 to 0.75", "0.76 to 0.99", "1.00", 
                         "1.10 to 1.24", "1.25 to 1.49", ">1.50")
  
  # assigning categories
  smr.data$SMR_category[smr.data$SMR >= 0.00 & smr.data$SMR < 0.49] = -3
  smr.data$SMR_category[smr.data$SMR >= 0.50 & smr.data$SMR < 0.75] = -2
  smr.data$SMR_category[smr.data$SMR >= 0.76 & smr.data$SMR < 0.99] = -1
  smr.data$SMR_category[smr.data$SMR >= 1.00 & smr.data$SMR < 1.09] = 0
  smr.data$SMR_category[smr.data$SMR >= 1.10 & smr.data$SMR < 1.24] = 1
  smr.data$SMR_category[smr.data$SMR >= 1.25 & smr.data$SMR < 1.49] = 2
  smr.data$SMR_category[smr.data$SMR >= 1.50 & smr.data$SMR < 3.00] = 3
  
  tm_shape(smr.data)+
    tm_fill(col = variable, 
            style = "cat",
            palette = "-RdBu",
            title = legend.title,
            labels = smr.category.list)+
    tm_borders(lw = 0.6)+
    tm_layout(legend.position = c(0.75,"bottom"),
              legend.text.size = 0.5,
              legend.title.size = 0.7,
              frame = FALSE)+
    tm_credits(title, 
               position = c(0.2, 0.8), 
               size = 1)
}

# Invoking function ------------------------------------------------------------
SMR_2017_map <- create.smr.map(SMR_2017, title = "2017")

SMR_2018_map <- create.smr.map(SMR_2018, title = "2018")

SMR_2019_map <- create.smr.map(SMR_2019, title = "2019")

SMR_2020_map <- create.smr.map(SMR_2020, title = "2020")

# Layout maps ------------------------------------------------------------------
tmap::tmap_arrange(SMR_2017_map, SMR_2018_map, SMR_2019_map, SMR_2020_map, ncol = 2)

```

# Extract the population living within waterbody buffers by catchment area

```{r, message=FALSE, warning=FALSE}

# Helper function to calculate estimated number of people living within waterbody buffers
# in each catchment area
estimate.buffer.pop <- function(catchment.population, buffers, catchment.area){
  
  # Extract population estimates from WorldPop raster
  buffers$buffer_pop <- raster::extract(catchment.population,
                                        buffers, 
                                        fun = sum, 
                                        na.rm = TRUE)
                                               
                                              
  # Find which catchment each polygon belongs to using its centroid - a point dataset 
  # representing the geographic center-points of the polygons 
  # buffer_by_catchment <- st_intersection(st_centroid(buffers), catchment.area)
  buffer_by_catchment <- sf::st_centroid(buffers) |>
    sf::st_intersection(catchment.area)
  
  # Notice that the buffer_catchment is comprised of separate POLYGONS (buffer_by_catchment$x). 
  # The first step is to “dissolve” away these POLYGONS into one MULTIPOLYGON. 
  # There is no sf equivalent to the QGIS or ArcMap “dissolve” operation. 
  # Instead we use a combination of group_by and summarize from the dplyr package. 
  # Stats::aggregate from sf package, and dplyr::summarize both do essentially the same.
   buffer_pop_aggregated <- buffer_by_catchment |> 
     dplyr::group_by(DN) |>
     dplyr::summarize(buffer_pop_aggregated = round(sum(buffer_pop, na.rm = TRUE)))

  buffer_pop <- merge(catchment.area, st_drop_geometry(buffer_pop_aggregated),
                      by = 'DN', all.x = TRUE)
  
  
  
  return(out = buffer_pop)
  
}

# Invoking the function and calculating proportion of 
# catchment population living within buffers
# 2017 buffer population -------------------------------------------------------
buffer_pop_1km_2017 <- estimate.buffer.pop(
  kasungu_population_2017, 
  buffer_1km_2017, 
   malaria_pop_by_catchment_2017) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |>
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0))) 

buffer_pop_2km_2017 <- estimate.buffer.pop(
  kasungu_population_2017,
  buffer_2km_2017,
  malaria_pop_by_catchment_2017) |>
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |>
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100)) |> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

buffer_pop_3km_2017 <- estimate.buffer.pop(
  kasungu_population_2017,
  buffer_3km_2017,
  malaria_pop_by_catchment_2017) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |>
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

# 2018 buffer population -------------------------------------------------------
buffer_pop_1km_2018 <- estimate.buffer.pop(
  kasungu_population_2018,
  buffer_1km_2018,
  malaria_pop_by_catchment_2018) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

buffer_pop_2km_2018 <- estimate.buffer.pop(
  kasungu_population_2018,
  buffer_2km_2018,
  malaria_pop_by_catchment_2018) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |>
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

buffer_pop_3km_2018 <- estimate.buffer.pop(
  kasungu_population_2018,
  buffer_3km_2018,
  malaria_pop_by_catchment_2018) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

# 2019 buffer population -------------------------------------------------------
buffer_pop_1km_2019 <- estimate.buffer.pop(
  kasungu_population_2019,
  buffer_1km_2019,
  malaria_pop_by_catchment_2019) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

buffer_pop_2km_2019 <- estimate.buffer.pop(
  kasungu_population_2019,
  buffer_2km_2019,
  malaria_pop_by_catchment_2019) |>
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0))) # replace NA with zero

buffer_pop_3km_2019 <- estimate.buffer.pop(
  kasungu_population_2019,
  buffer_3km_2019,
  malaria_pop_by_catchment_2019) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |>
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

# 2020 buffer population -------------------------------------------------------
buffer_pop_1km_2020 <- estimate.buffer.pop(
  kasungu_population_2020,
  buffer_1km_2020,
  malaria_pop_by_catchment_2020) |>
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

buffer_pop_2km_2020 <- estimate.buffer.pop(
  kasungu_population_2020,
  buffer_2km_2020,
  malaria_pop_by_catchment_2020) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100))|> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))

buffer_pop_3km_2020 <- estimate.buffer.pop(
  kasungu_population_2020,
  buffer_3km_2020,
  malaria_pop_by_catchment_2020) |> 
  dplyr::rename(catchment_pop = pop,
                buffer_pop = buffer_pop_aggregated) |> 
  dplyr::mutate(
    prop_buffer_catchment_pop = round((buffer_pop/catchment_pop)*100)) |> 
  dplyr::mutate(across(everything(), .fns = ~replace_na(.,0)))


```

# Scatter plots of SMR against the proportion of the catchment population living waterbody buffers

A correlation coeeficient of more than zero (cor.coeff r \> 0.1) indicates some positive association between the SMR and the buffer population variables. That is, SMR of dry season malaria increases with increase in number of people surrounding water bodies. This implies that as the population of people living near water bodies increases, the risk of dry season malaria increases as well.

```{r, message=FALSE, warning=FALSE, fig.height=15, fig.width=11, fig.cap='Fig 11. Relationship between standardised morbidity ratio and living near waterbodies'}

# Helper function to tidy and bind the SMR and proportion of -------------------
# buffer-catchment population data frames
tidy.data <- function(smr.df, 
                      proportion.pop.1km, 
                      proprotion.pop.2km,
                      proportion.pop.3km){

# Convert the sf objects to data frames-------------------------------------------
smr_df <- as.data.frame(smr.df) |> 
  dplyr::select(rowID, Names, SMR)

proportion_pop_1km_df <- as.data.frame(proportion.pop.1km) |> 
  dplyr::select(rowID, prop_pop_1km = `prop_buffer_catchment_pop`)

proportion_pop_2km_df <- as.data.frame(proprotion.pop.2km) |> 
  dplyr::select(rowID, prop_pop_2km = `prop_buffer_catchment_pop`)

proportion_pop_3km_df <- as.data.frame(proportion.pop.3km) |>
  dplyr::select(rowID, prop_pop_3km = `prop_buffer_catchment_pop`)

# Merge SMR and population data frames -----------------------------------------
combined_1 <- merge(smr_df, proportion_pop_1km_df, by = "rowID", all = TRUE)

combined_2 <- merge(proportion_pop_2km_df, proportion_pop_3km_df)

combined_fully <- merge(combined_1, combined_2, by = "rowID", all = TRUE)

}

# Invoking the function --------------------------------------------------------
smr_pop_2017 <- tidy.data(SMR_2017, buffer_pop_1km_2017, buffer_pop_2km_2017, buffer_pop_3km_2017)

smr_pop_2018 <- tidy.data(SMR_2018, buffer_pop_1km_2018, buffer_pop_2km_2018, buffer_pop_3km_2018)

smr_pop_2019 <- tidy.data(SMR_2019, buffer_pop_1km_2019, buffer_pop_2km_2019, buffer_pop_3km_2019)

smr_pop_2020 <- tidy.data(SMR_2020, buffer_pop_1km_2020, buffer_pop_2km_2020, buffer_pop_3km_2020)

# Helper function to create scatter plots --------------------------------------
create.scatter.plot <- function(smr.pop.df, 
                                independent.var = NA,
                                dependent.var = "SMR",
                                x.label = NA,
                                plot.title = NA){
  
  scatter.plot <- ggpubr::ggscatter(smr.pop.df,          # data frame
                                    x = independent.var, # x-axis variable
                                    y = dependent.var,   # y-axis variable
                                    add = "reg.line",    # Add regression line
                                    conf.int = TRUE,     # Add confidence interval
                                    add.params = list(color = "red",
                                                      fill = "lightgray"),
                                    palette = "jco",     # journal color palette. see ?ggpar
                                    xlab = x.label,      # x-axis label
                                    ylab = "SMR",        # y-axis label
                                    title = plot.title)+    
                  ggpubr::stat_cor(label.y = 3)+         # Add correlation coefficient
                  ggpubr::font("title", size = 10, face = "bold")+
                  ggpubr::font("xlab", size = 10)+
                  ggpubr::font("ylab", size = 10)
 
  return(scatter.plot)
  
}

# Invoking function 
# 2017 scatter plots ------------------------------------------------------------

scatter_1km_2017 <- create.scatter.plot(
  smr_pop_2017, independent.var = "prop_pop_1km",
  x.label = "Percentage of catchment population \nliving in 1km buffer",
  plot.title = "2017")

scatter_2km_2017 <- create.scatter.plot(
  smr_pop_2017, independent.var = "prop_pop_2km",
  x.label = "Percentage of catchment population \nliving in 2km buffer",
  plot.title = "2017")

scatter_3km_2017 <- create.scatter.plot(
  smr_pop_2017, independent.var = "prop_pop_3km",
  x.label = "Percentage of catchment population \nliving in 3km buffer",
  plot.title = "2017")

# 2018 scatter plots -----------------------------------------------------------
scatter_1km_2018 <- create.scatter.plot(
  smr_pop_2018, independent.var = "prop_pop_1km",
  x.label = "Percentage of catchment population \nliving in 1km buffer",
  plot.title = "2018")

scatter_2km_2018 <- create.scatter.plot(
  smr_pop_2018, independent.var = "prop_pop_2km",
  x.label = "Percentage of catchment population \nliving in 2km buffer",
  plot.title = "2018")

scatter_3km_2018 <- create.scatter.plot(
  smr_pop_2018, independent.var = "prop_pop_3km",
  x.label = "Percentage of catchment population \nliving in 3km buffer",
  plot.title = "2018")

# 2019 scatter plots -----------------------------------------------------------
scatter_1km_2019 <- create.scatter.plot(
  smr_pop_2019, independent.var = "prop_pop_1km",
  x.label = "Percentage of catchment population \nliving in 1km buffer",
  plot.title = "2019")

scatter_2km_2019 <- create.scatter.plot(
  smr_pop_2019, independent.var = "prop_pop_2km",
  x.label = "Percentage of catchment population \nliving in 2km buffer",
  plot.title = "2019")

scatter_3km_2019 <- create.scatter.plot(
  smr_pop_2019, independent.var = "prop_pop_3km",
  x.label = "Percentage of catchment population \nliving in 3km buffer",
  plot.title = "2019")

# 2020 scatter plots -----------------------------------------------------------
scatter_1km_2020 <- create.scatter.plot(
  smr_pop_2020, independent.var = "prop_pop_1km",
  x.label = "Percentage of catchment population \nliving in 1km buffer",
  plot.title = "2020")

scatter_2km_2020 <- create.scatter.plot(
  smr_pop_2020, independent.var = "prop_pop_2km",
  x.label = "Percentage of catchment population \nliving in 2km buffer",
  plot.title = "2020")

scatter_3km_2020 <- create.scatter.plot(
  smr_pop_2020, independent.var = "prop_pop_3km",
  x.label = "Percentage of catchment population \nliving in 3km buffer",
  plot.title = "2020")

# Arrange the plots ------------------------------------------------------------
ggpubr::ggarrange(scatter_1km_2017, scatter_2km_2017, scatter_3km_2017,
                  scatter_1km_2018, scatter_2km_2018, scatter_3km_2018,
                  scatter_1km_2019, scatter_2km_2019, scatter_3km_2019, 
                  scatter_1km_2020, scatter_2km_2020, scatter_3km_2020,
                  ncol = 3, nrow = 4)

```

# Model fitting

The findings from the SMR calculation above suggest the risk of dry season malaria transmission varies depending on the proportion of people living in waterbody buffers and year, so we consider a model with an interaction between proportion of people close to dams and year. We would like to explain dry season malaria risk based on the number of people living close to dams and the year.

We also compare the effect of removing intercept from the multiple linear regression. Mathematically, $𝜷_0 = 0$. Hence our multivariate model without intercept can be written as: $$ln (E(y)) = {𝜷_1} {x_i}_{1} + ln(𝒆_𝒊)$$ 

where,
$i = 1,2,3,⋯,n$
dependent variable, 𝑦 = observed malaria cases;
𝐸(𝑦) = expected count value;
independent variables, 𝑥 = percentage of people living near dams and year; and
offset, 𝑒 = expected malaria cases.

To cope with the malaria count data coming from populations of different sizes, we specify an offset argument. This adds a constant term for each row of the data in the model. The log of the expected cases is used in the offset term.


Summary outputs:

`Estimate`    : the `intercept` ($𝜷_0$) and the beta coefficient estimates associated to each predictor variable.

`Std.Error`   : the `standard error` of the coefficient estimates. This represents the accuracy of the coefficients. The larger the standard error, the less confident we are about the estimate.

`t value`     : the `t-statistic`, which is the coefficient estimate (column 2) divided by the standard error of the estimate (column 3). For a given the predictor, the `t-statistic` evaluates whether or not there is significant association between the predictor and the outcome variable, i.e., whether the beta coefficient of the predictor is significantly different from zero.

`Pr(>|t|)`    : The `p-value` corresponding to the `t-statistic`. The smaller the `p-value`, the more significant the estimate is.

`Residuals`   : Provide a quick view of the distribution of the residuals, which by definition have a mean zero. Therefore, the `median` should not be far from zero, and the minimum (`min`)and maximum (`max`) should be roughly equal in absolute value.

`Coefficients`: Shows the regression beta coefficients and their statistical significance. Predictor variables, that are significantly associated to the outcome variable, are marked by stars.

`Residual standard error` (`RSE`), and `R-squared` ($R^2$)  metrics tell how well the model fits to our data. An (adjusted) $R^2$ that is close to 1 indicates that a large proportion of the variability in the outcome has been explained by the regression model. A number near 0 indicates that the regression model did not explain much of the variability in the outcome.

```{r}
# Combine data for model fitting -----------------------------------------------
model_data_2017 <- merge(expected_malaria_2017, smr_pop_2017, by = "rowID", all = TRUE) |>
  dplyr::select(-Names.y) |> 
  dplyr::rename(Names = Names.x)

model_data_2018 <-  merge(expected_malaria_2018, smr_pop_2018, by = "rowID", all = TRUE) |> 
  dplyr::select(-Names.y) |> 
  dplyr::rename(Names = Names.x)

model_data_2019 <-  merge(expected_malaria_2019, smr_pop_2019, by = "rowID", all = TRUE) |>
  dplyr::select(-Names.y) |> 
  dplyr::rename(Names = Names.x)

model_data_2020 <-  merge(expected_malaria_2020, smr_pop_2020, by = "rowID", all = TRUE) |> 
  dplyr::select(-Names.y) |>
  dplyr::rename(Names = Names.x)


# Prep model data --------------------------------------------------------------
df2017 <- model_data_2017 |> 
  dplyr::as_tibble() |> 
    dplyr::rename(observed_cases = observed_2017,
                  expected_cases = expected_2017,
                  health_facility = Names) |> 
    dplyr::select(-geometry, -fid,-DN, -X, -SMR, 
                  -pop_2017, -dr_2018, -dr_2019, -dr_2020)

df2017$year <- "2017" # add new column

# df2017 <- cbind(df2017, year = "2017") # alternatively

df2018 <- model_data_2018 |> 
  dplyr::as_tibble() |> 
    dplyr::rename(observed_cases = observed_2018,
                  expected_cases = expected_2018) |> 
    dplyr::select(-geometry, -fid,-DN, -X, -SMR,
                  -pop_2018,-dr_2017, -dr_2019, -dr_2020)

df2018$year <- "2018"

colnames(df2018) <- colnames(df2017) # match columns names

df2019 <- model_data_2019 |> 
  dplyr::as_tibble() |> 
    dplyr::rename(observed_cases = observed_2019,
                  expected_cases = expected_2019) |> 
    dplyr::select(-geometry, -fid,-DN, -X, -SMR,
                  -pop_2019, -dr_2017, -dr_2018, -dr_2020)

df2019$year <- "2019"

colnames(df2019) <- colnames(df2017) # match columns names

df2020 <- model_data_2020 |> 
  dplyr::as_tibble() |> 
    dplyr::rename(observed_cases = observed_2020,
                  expected_cases = expected_2020) |> 
    dplyr::select(-geometry, -fid,-DN, -X, -SMR,
                  -pop_2020, -dr_2017, -dr_2018, -dr_2019) 

df2020$year <- "2020"

colnames(df2020) <- colnames(df2017) # match columns names

model_data <- rbind(df2017, df2018, df2019, df2020)

model_data <- imputeTS::na.replace(model_data, 0) # replace NA with zero


model_data |>     # View model data in table format
  gt::gt() |> 
  gt::tab_style(style = list(cell_text(align = "center")),
                locations = cells_column_labels() ) |> 
  gt::cols_label(health_facility = "Health facility",
                 observed_cases = "Observed cases",
                 expected_cases = "Expected cases",
                 prop_pop_1km = "Proportion of population in 1km buffers%",
                 prop_pop_2km = "Proportion of population in 2km buffers%",
                 prop_pop_3km	= "Proportion of population in 3km buffers%",
                 year = "Year")


# Model fitting 
# 1km model --------------------------------------------------------------------
multivariate_1km <- glm(observed_cases~1+prop_pop_1km+year+offset(log(expected_cases)),
                        data = model_data, family = poisson(link = "log"))

#summary.glm(multivariate_1km)
report::report(multivariate_1km)


# Check effect of removing intercept.
# When you remove an intercept from a regression model, you’re setting 
# it equal to 0 rather than estimating it from the data.
multivariate_1km_no_intercept <- glm(observed_cases~0+prop_pop_1km+year, # leaving the intercept out 
                                     offset = log(expected_cases),
                                     data = model_data, 
                                     family = poisson(link = "log"))

#summary.glm(multivariate_1km_no_intercept)
report::report(multivariate_1km_no_intercept)

sjPlot::tab_model(multivariate_1km, show.r2 = FALSE, show.aic = TRUE,
                  digits = 3, digits.re = 3)

sjPlot::tab_model(multivariate_1km_no_intercept, 
                  show.r2 = FALSE, show.aic = TRUE,
                  digits = 3, digits.re = 3)



# Alternatively
# multivariate_1km_rate <- glm(observed_cases~prop_pop_1km+year+offset(log_expected),
#                              data = model_data, family = poisson(link = "log"))
 
# summary(multivariate_1km_rate)
# report:report(multivariate_1km_rate)

# 2km model --------------------------------------------------------------------

multivariate_2km <- glm(observed_cases~1+prop_pop_2km+year+offset(log(expected_cases)),
                        data = model_data, family = 'poisson')

# summary(multivariate_2km)
report::report(multivariate_2km)

# Check effect of removing intercept
multivariate_2km_no_intercept <- glm(observed_cases~prop_pop_2km+year-1,
                                     offset = log(expected_cases),
                                     data = model_data, 
                                     family = poisson(link = "log"))

# summary(multivariate_2km_no_intercept)
report::report(multivariate_2km_no_intercept)

sjPlot::tab_model(multivariate_2km, 
                  show.r2 = FALSE, show.aic = TRUE,
                  digits = 3, digits.re = 3)

sjPlot::tab_model(multivariate_2km_no_intercept, 
                  show.r2 = FALSE, show.aic = TRUE,
                  digits = 3, digits.re = 3)


# 3km model --------------------------------------------------------------------
multivariate_3km <- glm(observed_cases~prop_pop_3km+year+offset(log(expected_cases)),
                        data = model_data, family = 'poisson')


# summary(multivariate_3km)
report::report(multivariate_3km)

```






