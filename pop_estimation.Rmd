---
title: "Analysis of Role of Dams on Recorded Dry Season Malaria Incidences in Kasungu"
output: html_document
latex_engine: MiKTeX
date: " Last edited `r format(Sys.time(),'%d %B %Y')`"
---
This geospatial model uses routinely collected malaria case data, population data and remotely sensed data, such as open and vegetated water bodies, to estimate population living around open water bodies, and ultimately quantify the association between proximity to larval habitat and malaria risk in health facility catchment areas in Kasungu. The buffer layer around waterbodies are created and then combined with population data in raster format to estimate the total population that is within the buffer. The data used spans from 2015 to 2020 and was derived from digitized DHIS2 malaria records, accessibility mapping, aggregated population geospatial layer and TropWet tool in Google Earth Engine. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center', echo = TRUE)
```

### Load packages

Loading the R packages that will be used to read in, view, transform and model the malaria cases and spatial datasets.

```{r, warning = FALSE, message = FALSE}
library(spatialEco)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(plotly)
library(lubridate)
library(knitr)
library(raster)
library(rgdal)
library(rgeos)
library(sf)
library(sp)
library(tmap)
library(spdep)
library(maptools)
library(gridExtra)
library(grid)
library(exactextractr)
library(DataExplorer)
library(mapview)
`%>%` <- magrittr::`%>%`
```

### Tell R where the data is

```{r}
here::here()
```

### Load datasets

The total dry season malaria cases recorded at health-care facilities in Kasungu from 2017 to 2019 are contained in the `KasunguData.csv` sourced from https://dhis2.health.gov.mw/. The `kasungu_facility_catchments_2004.shp` shapefile also contains the population and health information within each health-facility catchment area in Kasungu district. The aggregated population raster layers for Malawi e.g.,`ku_pop_2017_1km_aggregated.tif` were downloaded from the Open Spatial and Demographic and Data Research website: https://www.worldpop.org/geodata/country?iso3=MWI. These layers estimate total number of people per grid-cell. The units are number of people per pixel with country totals adjusted to match the corresponding official United Nations population estimates. The datasets were downloaded in Geotiff at a resolution of 1km and are projected in Geographic Coordinate System, WGS84. The `kasungu_water.shp`and `water_bodies` layers contain open and vegetated waterbodies polygons, detected using the Tropical Wetland Unmixing Tool (TropWet). TropWet is a Google Earth Engine hosted toolbox that uses the Landsat archive to map tropical wetlands and can be accessed through: https://www.aber.ac.uk/en/dges/research/earth-observation-laboratory/research/tropwet/

```{r, Kasungu water bodies polygons, malaria cases by health facility catchments and population layers, message= FALSE}

# 2017, 2018 and 2019 dry season malaria cases 
dry_season_malaria_2015_2019 <- read.csv(here::here("data", "dry_season_malaria 2015-2019.csv"))

# Explore malaria data
# dry_season_malaria_2015_2019 %>% dplyr::glimpse() %>% 
#   DataExplorer::introduce() %>% 
#   DataExplorer::plot_missing()

# Export 2017, 2018 and 2019 dry season malaria cases
write.csv(dry_season_malaria_2015_2019, file = "data/dry_season_malaria_2017_2019.csv")

write.table(dry_season_malaria_2015_2019, file = "dry_season_malaria_2017_2019.txt", 
            sep = ",", quote = FALSE, row.names = FALSE)

# 2020 dry season malaria cases
ku_malaria_2020 <- read.csv(here::here("data", "dry_season_malaria_2020.csv"))

ku_malaria_2020 %>% dplyr::glimpse()

# Merge 2015 to 2019 dry season malaria case data with 2020 data
dry_season_malaria_2017_2020 <- cbind.data.frame(dry_season_malaria_2015_2019, ku_malaria_2020) 
 
dry_season_malaria_2017_2020 <- dry_season_malaria_2017_2020[,c("FID", "Names", "dr_2017", 
                                                                "dr_2018", "dr_2019", "dr_2020",
                                                                "LONGITU", "LATITUD")]

# Export 'dry season malaria 2017-2020' as csv
write.csv(dry_season_malaria_2017_2020, file = "data/dry_season_malaria_2017_2019.csv")

dry_season_malaria_2017_2020 %>% dplyr::glimpse()

# Kasungu district boundary shapefile 
kasungu_district <- st_read(here::here("data", "kasungu_district.shp"))
  
# Kasungu health facility catchment boundary shapefiles
malire <- sf::st_read(here::here("data", "kasungu_health_facility_catchments.shp")) # outdated

malire_new <- sf::st_read(here::here("data", "Kasungu_new_health_fac_catchment_clip.shp")) # generated from accessibility mapping

# malire_new <- spTransform(malire_new, proj4string(malire_new))

# Kasungu population raster layer
kasungu_population_2017 <- raster(here::here("data", "ku_pop_2017_1km_aggregated.tif"))
kasungu_population_2018 <- raster(here::here("data", "ku_pop_2018_1km_aggregated.tif"))
kasungu_population_2019 <- raster(here::here("data", "ku_pop_2019_1km_aggregated.tif"))
kasungu_population_2020 <- raster(here::here("data", "ku_pop_2020_1km_aggregated.tif"))

# Open waterbodies polygons 
water_2017 <- st_read(here::here("data", "water_bodies_2017.shp"))
water_2018 <- st_read(here::here("data", "kasungu_2018_water.shp"))
water_2019 <- st_read(here::here("data", "kasungu_2019_water.shp"))
water_2020 <- st_read(here::here("data", "water_bodies_2020.shp"))

# Add a field ID to water bodies polygons 
water_2017$ID <- 1:nrow(water_2017)
water_2018$ID <- 1:nrow(water_2018)
water_2019$ID <- 1:nrow(water_2019)
water_2020$ID <- 1:nrow(water_2020)

```

### View the dry season malaria case data

We observe that Kasungu district has 30 health facilities classified as dispensary, health centre, district hospital and rural hospital and the highest malaria cases were recorded at Kasungu District Hospital. 

```{r, warning = FALSE, message = FALSE, fig.height = 10, fig.width = 8, fig.cap = 'Fig.1 The total malaria cases recorded at each health-care facility in Kasungu district'}

dry_season_malaria_2017_2020 %>% 
  glimpse() %>% 
  summary()

dry_season_malaria_2017_2020 %>%  
  plotly::plot_ly(y = ~Names,
                  x = ~dr_2017,
                  type = "bar",
                  orientation = 'h',
                  name = "2017") %>%
  plotly::add_trace(x = ~ dr_2018,
                    name = "2018") %>%
  plotly::add_trace(x = ~ dr_2019,
                    name = "2019") %>% 
  plotly::add_trace(x = ~ dr_2020,
                    name = "2020") %>% 
  plotly::layout(#barmode = "stack",
                 xaxis = list(title = "Total malaria cases"),
                 yaxis = list(title = ""),
                 hovermode = "compare",
                 margin = list(b = 10,
                               t = 10,
                               pad = 2))

```


### View location of Kasungu health-care facilities within health facility catchment area
Heath facility catchment area is the area from which a health facility attracts patients. The new health facility catchments polygon was generated from generic accessibility mapping script adapted from https://malariaatlas.org/wp-content/uploads/accessibility/R_generic_accessibilty_mapping_script.r The script requires two user supplied datasets: the `2015 friction surface`, which is available here:  http://www.map.ox.ac.uk/accessibility_to_cities/, and a user-supplied .csv of points `dry_season_malaria_2017_2020`. The accumulated cost algorithm `accCost` and `r.Cost` algorithm in GRASS GIS were run to make the final output map of new health facility catchment boundaries.
```{r, warning = FALSE, message = FALSE, fig.cap='Fig 2. Kasungu Health-care Facilities and Catchment Areas'}

# Using the is.na() function to remove health centres with missing longitude and latitude coordinates
# Aggregating Kasalika Health Centre and Kasungu District Hospital, and 
# Kaluluma Rural Hospital and Nkhamenya Rural Hospital malaria cases

# health_facility_aggregated <- dry_season_malaria_2017_2020[!is.na(dry_season_malaria_2017_2020$LONGITU),] %>% 
#   dplyr::filter(Names != "Kasalika Health Centre",
#                 Names != "Bua Health Centre",
#                 Names != "Kaluluma Rural Hospital") %>% 
#   dplyr::mutate(dr_2017 = ifelse(Names == "Kasungu District Hospital", 4528 + 16289, dr_2017), 
#                 dr_2018 = ifelse(Names == "Kasungu District Hospital", 4493 + 15821, dr_2018), 
#                 dr_2019 = ifelse(Names == "Kasungu District Hospital", 2729 + 10721, dr_2018), 
#                 dr_2020 = ifelse(Names == "Kasungu District Hospital", 4368 + 24424, dr_2020),
#                 dr_2017 = ifelse(Names == "Nkhamenya Rural Hospital", 2887 + 752, dr_2017), 
#                 dr_2018 = ifelse(Names == "Nkhamenya Rural Hospital", 851 + 3689, dr_2018), 
#                 dr_2019 = ifelse(Names == "Nkhamenya Rural Hospital", 533 + 4004, dr_2019),
#                 dr_2020 = ifelse(Names == "Nkhamenya Rural Hospital", 3587 + 5929, dr_2020),
#                 dr_2017 = ifelse(Names == "Mziza Health Centre", 3863 + 3489, dr_2017),
#                 dr_2018 = ifelse(Names == "Mziza Health Centre", 2815 + 1804, dr_2018),
#                 dr_2019 = ifelse(Names == "Mziza Health Centre", 2815 + 1804, dr_2019),
#                 dr_2020 = ifelse(Names == "Mziza Health Centre", 2397 + 6194, dr_2020)) 

zipatala_aggregated <- dry_season_malaria_2017_2020[complete.cases(dry_season_malaria_2017_2020),] %>% 
  dplyr::filter(Names != "Kasalika Health Centre",
                Names != "Bua Health Centre",
                Names != "Kaluluma Rural Hospital") 

zipatala_aggregated$dr_2017[which(zipatala_aggregated$Names == "Kasungu District Hospital")] <- 4528 + 16289

zipatala_aggregated$dr_2018[which(zipatala_aggregated$Names == "Kasungu District Hospital")] <- 4493 +15821

zipatala_aggregated$dr_2019[which(zipatala_aggregated$Names == "Kasungu District Hospital")] <- 2729 + 10721

zipatala_aggregated$dr_2020[which(zipatala_aggregated$Names == "Kasungu District Hospital")] <- 4368 + 24424
  
zipatala_aggregated$dr_2017[which(zipatala_aggregated$Names == "Nkhamenya Rural Hospital")] <- 2887 + 752

zipatala_aggregated$dr_2018[which(zipatala_aggregated$Names == "Nkhamenya Rural Hospital")] <- 851 + 3689

zipatala_aggregated$dr_2019[which(zipatala_aggregated$Names == "Nkhamenya Rural Hospital")] <- 533 + 4004

zipatala_aggregated$dr_2020[which(zipatala_aggregated$Names == "Nkhamenya Rural Hospital")] <- 3587 + 5929

zipatala_aggregated$dr_2017[which(zipatala_aggregated$Names == "Mziza Health Centre")] <- 3863 + 3489

zipatala_aggregated$dr_2018[which(zipatala_aggregated$Names == "Mziza Health Centre")] <- 2815 + 1804

zipatala_aggregated$dr_2019[which(zipatala_aggregated$Names == "Mziza Health Centre")] <- 2439 + 1740

zipatala_aggregated$dr_2020[which(zipatala_aggregated$Names == "Mziza Health Centre")] <- 6194 + 2397

# There are NA values in dry_season_malaria_2017_2020.csv, replace them by 0 and add a column to keep information
# dry_season_malaria_2017_2020$is_na = ifelse(is.na(dry_season_malaria_2017_2020$LONGITU), TRUE, FALSE)
# index = dry_season_malaria_2017_2020$is_na == TRUE
# dry_season_malaria_2017_2020[index, "LONGITU"] <- 0
# dry_season_malaria_2017_2020[index, "LATITUD"] <- 0
# 
# dry_season_malaria_2017_2020 <- SpatialPointsDataFrame(coords = dry_season_malaria_2017_2020[, 7:8],
#                                    data = dry_season_malaria_2017_2020[,1:6])

# write.csv(zipatala_aggregated, "data/Kasungu_malaria_2017_2020.csv")

health_facility_aggr_sf <- sf::st_as_sf(zipatala_aggregated,
                                        coords = c("LONGITU", "LATITUD"),
                                        crs = 4326, agr = "constant")


# Save as shapefile
# sf::st_write(health_facility_sf, "data/kasungu_zipatala_aggregated.shp", overwrite = TRUE)

# mapview::mapview(health_facility_aggr_sf)

# Set to interactive view
# tmap_mode('view')

old_catchment <- tm_shape(malire)+
  tm_polygons()+
  tm_shape(health_facility_aggr_sf)+
  tm_dots(size = .3, col = "blue", alpha = 0.5)+
  tm_text("Names", size = .3, just = "top", 
          col = "black", remove.overlap = TRUE)+
  tm_layout(frame = FALSE,
            title = "Old catchment boundaries",
            title.size = .8, 
            title.position = c("left", "top"))+
  tm_scale_bar(breaks = c(0, 10, 20), 
               text.size = .5)

new_catchment <- tm_shape(malire_new)+
  tm_polygons()+
  tm_shape(health_facility_aggr_sf)+
  tm_dots(size = .3, col = "blue", alpha = 0.5)+
  tm_text("Names", size = .3, just = "top", 
          col = "black", remove.overlap = TRUE)+
  tm_layout(frame = FALSE,
            title = "New catchment boundaries",
            title.size = .8, 
            title.position = c("left", "top"))+
  tm_compass(position=c("right", "top"))

tmap::tmap_arrange(old_catchment, new_catchment)

```


### View population and malaria rate for Malawi by health facility catchment area 

Using population and health information within each health facility catchment area we produce a choropleth map colored in proportion to a statistical variable that represents an aggregate summary of a geographic characteristic, in this case total population, population density, malaria rate and total malaria cases.

```{r, message = FALSE, fig.height = 7, fig.width = 9, fig.cap = 'Fig.3 Population and health information for each health facility catchment area'}
# Take a look at the variables, CRS and geometry type
# head(malire)

# Function to create a choropleth map from sf object
choroplethmap <- function(df, vname = NA, pal = NA, legend.title = NA){
  # choropleth map
  # df: simple feature polygon layer
  # vname: variable name (as character, in quotes)
  # pal: color palette
  # legend.title: legend title in quotes
  # returns:
  # a tmap element (plots a map)
  tm_shape(df)+
    tm_fill(col = vname, style = "quantile",
            palette = pal, n = 5, title = legend.title)+
    tm_borders()+
    tm_layout(legend.position = c("right","bottom"))
}


population <- choroplethmap(malire, vname = "POPULATION", 
                            pal = "Reds", legend.title = "Total population")

pop_density <- choroplethmap(malire, vname = "DENSITY", 
                             pal = "YlOrRd", legend.title = "Population density")

malaria_rate <- choroplethmap(malire, vname = "MALAR_RATE", 
                              pal = "BuGn", legend.title = "Malaria prevalence %")

malaria_cases <- choroplethmap(malire, vname = "MALARIA_CA", 
                               pal = "Purples", legend.title = "Malaria cases")

tmap_arrange(population, pop_density, malaria_rate, malaria_cases)

```


### View raster population metadata and estimated population per grid-cell

CRS for `kasungu_population` layers is already in WGS 84 UTM Zone 36 South, which is the base projected coordinate system for Malawi and has units in meters, hence no need to transform it.The highest estimated population per grid-cell is 7,949 people in 2020.

```{r, message = FALSE, warning = FALSE, fig.height = 9, fig.width = 10, fig.cap = 'Fig.4 Estimated total number of people per 1km grid-cell'}

# Check out the CRS and values of the population layers
kasungu_population_2017

kasungu_population_2018

kasungu_population_2019

kasungu_population_2020

# Function to create a raster population map
populationmap <- function(df, title){
  # population map
  # arguments:
  #   df:  aggregated population raster layer
  #   legend.title: legend title
  # returns:
  #   a tmap-element (plots a map)
  tm_shape(df)+
    tm_raster(palette = "Reds", title = title,
              breaks = c(0,100,200,400,600,800,1000,2000,4000,6000,8000))+
    tm_layout(legend.position = c("right", "bottom"),
              frame = FALSE)+
    tm_scale_bar(position = c("left", "bottom"))
}
# Set to static map
tmap_mode("plot")

pop_2017 <- populationmap(kasungu_population_2017, title = "2017 Population")

pop_2018 <- populationmap(kasungu_population_2018, title = "2018 Population")

pop_2019 <- populationmap(kasungu_population_2019, title = "2019 Population")

pop_2020 <- populationmap(kasungu_population_2020, title = "2020 Population")

tmap_arrange(pop_2017, pop_2018, pop_2019, pop_2020, nrow = 2) # Layout the maps

```

### Buffer, combine and transform TropWet derived waterbody polygons  

Buffers of 30m radius have been created around open waterbodies and the geometries of overlapping polygons are unioned together. `st_union` returns a single geometry `sfc` object, which is why `st_cast` and `st_as_sf` functions have been used to cast and convert the multipolygon buffer geometries to a dissolved or split polygon geometry collection.

```{r, message=FALSE, warning=FALSE}

surfaceWater_2017 <- sf::st_as_sf(st_cast(st_union(st_buffer(water_2017, dist = 30)), "POLYGON"))

surfaceWater_2018 <- sf::st_as_sf(st_cast(st_union(st_buffer(water_2018, dist = 30)), "POLYGON"))

surfaceWater_2019 <- sf::st_as_sf(st_cast(st_union(st_buffer(water_2019, dist = 30)), "POLYGON"))

surfaceWater_2020 <- sf::st_as_sf(st_cast(st_union(st_buffer(water_2020, dist = 30)), "POLYGON"))

```


### Create a function for computing buffers around open waterbody polygons  

```{r, message=FALSE, warning=FALSE}

waterbody_buffer <- function(waterbody, distance, catchment){
  
  #Buffer the 'water' vector file by 'distance' meters
  buffer_radiusk <- st_buffer(waterbody, distance)
  
  # Dissolve the buffers
  buffer_radiusk_union <- st_as_sf(st_cast(st_union(buffer_radiusk),"MULTIPOLYGON"))
  
  # Assign Attributes of the 'catchment' to each of the waterbodies. 
  int_radiusk <- st_intersection(buffer_radiusk_union, catchment)
  open_water_buffer <- st_as_sf(int_radiusk)
  
  # Polygons being seen to be in multiple catchments
  st_intersects(open_water_buffer, catchment)
  
  # Make the assumption that the attribute is constant throughout the geometry
  st_agr(open_water_buffer) = "constant"
  st_agr(catchment) = "constant"
  
  return(out = open_water_buffer)
}
```


### Create buffers using Kasungu open waterbodies and health-facility catchment boundary layers

`st_buffer` has been used to compute 1km, 2km and 3km buffers around each waterbody polygon. Then geometry of the buffer features are then combined resulting in resolved internal boundaries. Invalid waterbody polygons can be checked by using `st_is_valid` which returns by default NA on corrupt geometries.

```{r, message=FALSE, warning=FALSE}

# For 2017 TropWet surface water polygons
buffer_1km_2017 <- waterbody_buffer(waterbody = surfaceWater_2017, 
                                    distance = 1000, catchment = malire_new)

buffer_2km_2017 <- waterbody_buffer(waterbody = surfaceWater_2017, 
                                    distance = 2000, catchment = malire_new)

buffer_3km_2017 <- waterbody_buffer(waterbody = surfaceWater_2017, 
                                    distance = 3000, catchment = malire_new)

# For 2018 TropWet surface water polygons
buffer_1km_2018 <- waterbody_buffer(waterbody = surfaceWater_2018, 
                                    distance = 1000, catchment = malire)

buffer_2km_2018 <- waterbody_buffer(waterbody = surfaceWater_2018, 
                                    distance = 2000, catchment = malire)

buffer_3km_2018 <- waterbody_buffer(waterbody = surfaceWater_2018, 
                                    distance = 3000, catchment = malire)

# For 2019 TropWet surface water polygons
buffer_1km_2019 <- waterbody_buffer(waterbody = surfaceWater_2019, 
                                    distance = 1000, catchment = malire)

buffer_2km_2019 <- waterbody_buffer(waterbody = surfaceWater_2019, 
                                    distance = 2000, catchment = malire)

buffer_3km_2019 <- waterbody_buffer(waterbody = surfaceWater_2019, 
                                    distance = 3000, catchment = malire)

# For 2020 TropWet surface water polygons
buffer_1km_2020 <- waterbody_buffer(waterbody = surfaceWater_2020, 
                                    distance = 1000, catchment = malire)

buffer_2km_2020 <- waterbody_buffer(waterbody = surfaceWater_2020, 
                                    distance = 2000, catchment = malire)

buffer_3km_2020 <- waterbody_buffer(waterbody = surfaceWater_2020, 
                                    distance = 3000, catchment = malire)

```


### View the intersected buffers

```{r, fig.height=9, fig.width=10, fig.cap='Fig 5. Buffers around open waterbodies in Kasungu'}

# Map the buffers
buffermap <- function(df, boundary, title = NA){
  # function for creating buffer map in ggplot
  # arguments:
  #   df:  buffer polygon layer
  #   boundary: Kasungu district boundary layer
  #   title: main title
  # returns:
  #   a map-element (plots a map)
  ggplot(data = df)+
     geom_sf()+
     geom_sf(data = boundary, fill = NA)+
     theme_classic()+
     labs(title = title)
 }

# For 2017 
buffer1km_2017 <- buffermap(buffer_1km_2017, kasungu_district, title = "2017: 1km Buffers")
buffer2km_2017 <- buffermap(buffer_2km_2017, kasungu_district, title = "2017: 2km Buffers")
buffer3km_2017 <- buffermap(buffer_3km_2017, kasungu_district, title = "2017: 3km Buffers")

# For 2018
buffer1km_2018 <- buffermap(buffer_1km_2018, kasungu_district, title = "2018: 1km Buffers")
buffer2km_2018 <- buffermap(buffer_2km_2018, kasungu_district, title = "2018: 2km Buffers")
buffer3km_2018 <- buffermap(buffer_3km_2018, kasungu_district, title = "2018: 3km Buffers")

# For 2019
buffer1km_2019 <- buffermap(buffer_1km_2019, kasungu_district, title = "2019: 1km Buffers")
buffer2km_2019 <- buffermap(buffer_2km_2019, kasungu_district, title = "2019: 2km Buffers")
buffer3km_2019 <- buffermap(buffer_3km_2019, kasungu_district, title = "2019: 3km Buffers")

# For 2020
buffer1km_2020 <- buffermap(buffer_1km_2020, kasungu_district, title = "2020: 1km Buffers")
buffer2km_2020 <- buffermap(buffer_2km_2020, kasungu_district, title = "2020: 2km Buffers")
buffer3km_2020 <- buffermap(buffer_3km_2020, kasungu_district, title = "2020: 3km Buffers")
 
grid.arrange(buffer1km_2017, buffer1km_2018, buffer1km_2019, buffer1km_2020,
             buffer2km_2017, buffer2km_2018, buffer2km_2019, buffer2km_2020, 
             buffer3km_2017, buffer3km_2018, buffer3km_2019, buffer3km_2020, ncol = 4)

```


### Estimating population living in various distances from open water bodies and in each health facility catchment

Here, we create a function that uses open water bodies, health facility catchment boundary and population datasets to estimate the number of people living within 1km, 2km and 3km buffers surrounding the waterbodies. This involves overlaping and intersecting different data layers (buffers of waterbodies, catchment boundary, population raster, etc), so that we can apportion population from one layer to another. In this model, the layer with population estimate is `kasungu_population_*` and the target layer that does not have an estimate, but for which we desire one, is `kasungu_health_facility_catchment/malire`. The function returns an object called `finalized` that has estimated population within the buffers zones, and multipolygon geometry. 

```{r, message = FALSE, warning = FALSE}

nachulu <- function(water, distance, catchment, raster_population){
  # function to estimate population out of raster and vector layers
  # arguments:
  #    water: waterbody polygon layer
  #    distance: buffer distance in meters
  #    catchment: health facility catchment boundary layer generated from accessibility mapping
  #    raster_population: aggregated population raster layer
  # returns:
  #    finalized: sf objects with a data frame containing estimated population
  
  
  #Buffer the 'water' vector file by 'distance' meters
  buffer_radiusk <- st_buffer(water, distance)
  
  # Dissolve the buffers. Unioning geometries dissolves for instance internal polygon 
  # boundaries, which otherwise would lead to invalid MULTIPOLYGON errors in subsequent analysis.
  buffer_radiusk_union <- sf::st_as_sf(st_cast(st_union(buffer_radiusk),"POLYGON"))
  
  # Split the buffered water file by the boundaries of the catchment area. 
  # We don't want to allocate the attributes in this step 
  int_radiusk <- st_intersection(buffer_radiusk_union, st_geometry(catchment))
  water_int_radiusk <- sf::st_as_sf(int_radiusk)
  
  # Convert the MULTIPOLYGON object into several POLYGON objects
  water_int_radiusk <- st_cast(st_buffer(water_int_radiusk,0.0), "MULTIPOLYGON") %>% 
    st_cast("POLYGON")
  
  # Polygons being seen to be in multiple catchments
  st_intersects(water_int_radiusk, catchment)
  
  # Estimation of population within X kilometer buffer.
  # Extracting zonal statistics from a population raster layer. 
  # The population raster is a continuous gridded surface layer that assign an 
  # estimated population density value to every square in their grid. 
  # The population statistics are then summed and apportioned to the buffer polygons
  water_int_radiusk$pop_est<- raster::extract(raster_population, water_int_radiusk, 
                                              fun = sum, na.rm = TRUE)
  
  # Make the assumption that the attribute is constant throughout the geometry
  st_agr(water_int_radiusk) = "constant"
  st_agr(catchment) = "constant"
  
  # Find which catchment each polygon belongs to using its centroid - a point dataset 
  # representing the geographic center-points of the polygons 
  assign_catchment <- st_intersection(st_centroid(water_int_radiusk), catchment)
  
  
  # Calculated total population living X distance for each facility  
  # Notice that the assign_catchment is comprised of separate POLYGONS (assign_catchment$x). 
  # The first step is to “dissolve” away these POLYGONS into one MULTIPOLYGON. 
  # There is no sf equivalent to the ArcMap “dissolve” operation. 
  # Instead we use a combination of group_by and summarize from the dplyr package. 
  # Stats::aggregate from sf package, and dplyr::summarize both do essentially the same.
  npeople <- assign_catchment %>% dplyr::group_by(DN) %>%
    summarize(pop_estimate = round(sum(pop_est, na.rm = TRUE)))
  
  finalized <- merge(catchment, st_drop_geometry(npeople), by='DN', all.x = TRUE)
  return(out=finalized)
}

```


### Run the model to estimate population living around open waterbodies 

Using the `nachulu` function, here we estimate the number of people surrounding waterbodies in each health facility catchment area using attributes from the open waterbody buffers, health facility catchment boundary and aggregated population raster layers. That is, population living in various distances from open water bodies e.g. 1km, 2km and 3 km is estimated and assigned to health facilities.

```{r, message= FALSE, warning = FALSE}

# For 2017 ---------------------------------------------------------------------
# Estimate population living within 1km radius from water bodies
run1k_2017<- nachulu(water = surfaceWater_2017, distance = 1000, 
                     catchment = malire_new,
                     raster_population = kasungu_population_2017)

run1k_2017$pop_1km <- run1k_2017$pop_estimate

# Estimate population living within 2km radius from water bodies
run2k_2017<- nachulu(water = surfaceWater_2017, distance = 2000, 
                     catchment = malire_new, 
                     raster_population = kasungu_population_2017)

run2k_2017$pop_2km <- run2k_2017$pop_estimate

# Estimate population living within 3km radius from water bodies
run3k_2017<- nachulu(water = surfaceWater_2017, distance = 3000, 
                     catchment = malire_new, 
                     raster_population = kasungu_population_2017)

run3k_2017$pop_3km <- run3k_2017$pop_estimate


# For 2018 ---------------------------------------------------------------------
# Estimate population living within 1km radius from water bodies
run1k_2018<- nachulu(water = surfaceWater_2018, distance = 1000, 
                     catchment = malire_new, 
                     raster_population = kasungu_population_2018)

run1k_2018$pop_1km <- run1k_2018$pop_estimate

# Estimate population living within 2km radius from water bodies
run2k_2018<- nachulu(water = surfaceWater_2018, distance = 2000, 
                     catchment = malire_new, 
                     raster_population = kasungu_population_2018)

run2k_2018$pop_2km <- run2k_2018$pop_estimate

# Estimate population living within 3km radius from water bodies
 run3k_2018 <- nachulu(water = surfaceWater_2018, distance = 3000, 
                       catchment = malire_new, 
                       raster_population = kasungu_population_2018)
 
 run3k_2018$pop_3km <- run3k_2018$pop_estimate


# For 2019 ---------------------------------------------------------------------
# Estimate population living within 1km radius from water bodies
run1k_2019 <- nachulu(water = surfaceWater_2019, distance = 1000, 
                      catchment = malire_new, 
                      raster_population = kasungu_population_2019)

run1k_2019$pop_1km <- run1k_2019$pop_estimate

# Estimate population living within 2km radius from water bodies
run2k_2019<- nachulu(water = surfaceWater_2019, distance = 2000, 
                     catchment = malire_new, 
                     raster_population = kasungu_population_2019)

run2k_2019$pop_2km <- run2k_2019$pop_estimate

# Estimate population living within 3km radius from water bodies
run3k_2019<- nachulu(water = surfaceWater_2019, distance = 3000, 
                     catchment = malire_new, 
                     raster_population = kasungu_population_2019)

run3k_2019$pop_3km <- run3k_2019$pop_estimate


# For 2020 ---------------------------------------------------------------------
#  Estimate population living within 1km radius from water bodies
run1k_2020 <- nachulu(water = surfaceWater_2020, distance = 1000, 
                      catchment = malire_new, 
                      raster_population = kasungu_population_2020)

run1k_2020$pop_1km <- run1k_2020$pop_estimate

# Estimate population living within 2km radius from water bodies
run2k_2020 <- nachulu(water = surfaceWater_2020, distance = 2000, 
                      catchment = malire_new, 
                     raster_population = kasungu_population_2020)

run2k_2020$pop_2km <- run2k_2020$pop_estimate

# Estimate population living within 3km radius from water bodies
run3k_2020 <- nachulu(water = surfaceWater_2020, distance = 3000, catchment = malire_new, 
                     raster_population = kasungu_population_2020)

run3k_2020$pop_3km <- run3k_2020$pop_estimate
```


### View the estimated population

Map the outputs from the `nachulu` function: layers of polygons representing health facility catchment areas, with a field in  the  attribute  table containing the  estimated catchment population `pop_estimate` in 2017, 2018, 2019 and 2020. In areas where the input data is out of data, e.g, no presence of waterbody polygons, the estimated population is missing.
```{r, message = FALSE, warning = FALSE, fig.height = 8, fig.width = 11, fig.cap='Fig 6. Estimated population in Kasungu health facility catchments'}

# Function to create maps of estimated population out of sf objects from the nachulu function
estimatedpop <- function(df, vname = "pop_estimate", title, legend.title = NA){
  # estimated population map
  # df: estimated population layer from nachulu function
  # vname: variable name (as character, in qoutes)
  # title: map title in quotes
  # legend.title: legend title in qoutes
  # returns:
  #   a tmap-element (plots a map)
  tm_shape(df)+
    tm_fill(col = vname, style = "quantile", 
            palette = "Reds", n = 5, title = legend.title)+
    tm_borders()+
    tm_layout(legend.position = c(0.7,"bottom"),
              title.size = .3,
              frame = FALSE)+
    tm_credits(title, position = c(0,0.75), size = 1)
}

run1k_2017_map <- estimatedpop(run1k_2017, title = "2017: 1km buffers", 
                               legend.title = "Estimated \n population")

run2k_2017_map <- estimatedpop(run2k_2017, title = "2017: 2km buffers", 
                               legend.title = "Estimated \n population")

run3k_2017_map <- estimatedpop(run3k_2017, title = "2017: 3km buffers", 
                               legend.title = "Estimated \n population")

run1k_2018_map <- estimatedpop(run1k_2018, title = "2018: 1km buffers", 
                               legend.title = "Estimated \n population")

run2k_2018_map <- estimatedpop(run2k_2018, title = "2018: 2km buffers", 
                               legend.title = "Estimated \n population")

run3k_2018_map <- estimatedpop(run3k_2018, title = "2018: 3km buffers", 
                               legend.title = "Estimated \n population")

run1k_2019_map <- estimatedpop(run1k_2019, title = "2019: 1km buffers", 
                               legend.title = "Estimated \n population")

run2k_2019_map <- estimatedpop(run2k_2019, title = "2019: 2km buffers", 
                               legend.title = "Estimated \n population")

run3k_2019_map <- estimatedpop(run3k_2019, title = "2019: 3km buffers", 
                               legend.title = "Estimated \n population")

run1k_2020_map <- estimatedpop(run1k_2020, title = "2020: 1km buffers", 
                               legend.title = "Estimated \n population")

run2k_2020_map <- estimatedpop(run2k_2020, title = "2020: 2km buffers", 
                               legend.title = "Estimated \n population")

run3k_2020_map <- estimatedpop(run3k_2020, title = "2020: 3km buffers", 
                               legend.title = "Estimated \n population")

tmap_arrange(run1k_2017_map, run2k_2017_map, run3k_2017_map, 
             run1k_2018_map, run2k_2018_map, run3k_2018_map,
             run1k_2019_map, run2k_2019_map, run3k_2019_map,
             run1k_2020_map, run2k_2020_map, run3k_2020_map, ncol = 3)
```


### Merge estimated population within the various buffers into a single data frame

First, we need to convert the sf outputs from the `nachulu function` to a plain data frame with `as.data.frame`, which drops the geometry and gives back a plain data frame

```{r, message=FALSE, warning=FALSE}

# Convert sf objects to plain data frame
# 2017 -------------------------------------------------------------------------
run1k_2017_df <- as.data.frame(run1k_2017)[,c("DN", "pop_1km")]
run2k_2017_df <- as.data.frame(run2k_2017)[,c("DN", "pop_2km")]
run3k_2017_df <- as.data.frame(run3k_2017)[,c("DN", "pop_3km")]

# 2018 -------------------------------------------------------------------------
run1k_2018_df <- as.data.frame(run1k_2018)[,c("DN", "pop_1km")]
run2k_2018_df <- as.data.frame(run2k_2018)[,c("DN", "pop_2km")]
run3k_2018_df <- as.data.frame(run3k_2018)[,c("DN", "pop_3km")]

# 2019 -------------------------------------------------------------------------
run1k_2019_df <- as.data.frame(run1k_2019)[,c("DN", "pop_1km")]
run2k_2019_df <- as.data.frame(run2k_2019)[,c("DN", "pop_2km")]
run3k_2019_df <- as.data.frame(run3k_2019)[,c("DN", "pop_3km")]

# 2020 -------------------------------------------------------------------------
run1k_2020_df <- as.data.frame(run1k_2020)[,c("DN", "pop_1km")]
run2k_2020_df <- as.data.frame(run2k_2020)[,c("DN", "pop_2km")]
run3k_2020_df <- as.data.frame(run3k_2020)[,c("DN", "pop_3km")]

# Merge the data frames. NB: one important variable 'dry season malaria cases' 
# is yet to be added to the data frames
finalized_2017_df <- cbind.data.frame(run1k_2017_df, run2k_2017_df, run3k_2017_df)

finalized_2018_df <- cbind.data.frame(run1k_2018_df, run2k_2018_df, run3k_2018_df)

finalized_2019_df <- cbind.data.frame(run1k_2019_df, run2k_2019_df, run3k_2019_df)

finalized_2020_df <- cbind.data.frame(run1k_2020_df, run2k_2020_df, run3k_2020_df)


# Exclude unnecessary columns and rows
# 2017 -------------------------------------------------------------------------
finalized_2017_df <- finalized_2017_df[,c("DN", "pop_1km", "pop_2km", "pop_3km")] 
             
finalized_2017_df <- cbind("Fid" = rownames(finalized_2017_df), finalized_2017_df)

# 2018 -------------------------------------------------------------------------
finalized_2018_df <- finalized_2018_df[,c("DN", "pop_1km", "pop_2km", "pop_3km")]

finalized_2018_df <- cbind("Fid" = rownames(finalized_2018_df), finalized_2018_df)

# 2019 -------------------------------------------------------------------------
finalized_2019_df <- finalized_2019_df[,c("DN", "pop_1km", "pop_2km", "pop_3km")] 
             
finalized_2019_df <- cbind("Fid" = rownames(finalized_2019_df), finalized_2019_df)

# 2020 -------------------------------------------------------------------------
finalized_2020_df <- finalized_2020_df[,c("DN", "pop_1km", "pop_2km", "pop_3km")] 
             
finalized_2020_df <- cbind("Fid" = rownames(finalized_2020_df), finalized_2020_df) 

```


### Tidy and merge the estimated population data with the malaria data

The estimated population within 1km, 2km and 3km buffers around water bodies is now being merged with the 2017 to 2020 dry season malaria dataframe using a user-defined function: `organize`
```{r, message=FALSE, warning=FALSE, fig.height = 7, fig.width = 9, fig.cap = 'Fig. 7: Dry season malaria cases, Kasungu'}

# Create a function that merges and tidy the population and malaria dataframes 
organize <- function(malaria_data, pop_data){
  
  # function to merge, tidy dry season malaria and estimated population datasets
  # arguments:
  #   malaria_data: sf point object with a data frame containing aggregated 
  #                 malaria data at health facilities level
  #   pop_data: sf polygon object with a data frame containing the estimated population
  # returns:
  #   hfc_malaria_pop: sf objects with a data frame containing dry season malaria and estimated population


  # Convert sf objects to spatial
  estimated_pop_shp <- as(pop_data, "Spatial")
  malaria_shp <- as(malaria_data, "Spatial")

  # Match CRS
  malaria_shp <- spTransform(malaria_shp, crs(estimated_pop_shp))

  # Overlay aggregated health facility points and extract estimated population
  # Using 'point.in.poly' to return a point spatial object, in this case location of health facilities
  # and estimated population instead of sp::over function, which simply returns 
  # a data frame, with the same no. rows.
  # Argument 'sp = TRUE' returns an sp class object, else returns sf class object
  health_facilities_pop <- spatialEco::point.in.poly(malaria_shp, estimated_pop_shp, sp = TRUE) 
 
  # head(health_facilities_pop@data)

  # Add the extracted ID, health facility names, dry season malaria cases and estimated population to 
  # the health facility catchments (hfc)
  hfc_pop_malaria_shp <- merge(estimated_pop_shp, health_facilities_pop, 
                               by.x = "FID", by.y = "DN")

  # Convert the merged shapefile containing estimated population and malaria data to sf-object
  hfc_pop_malaria_sf <- sf::st_as_sf(hfc_pop_malaria_shp)

  # Tidy the data by reordering columns and dropping those not needed
  # First, get column names
  # colnames(hfc_pop_malaria_sf)
  # [1] "DN"           "pop_1km"      "pop_estimate" "FID"          "Names"        "dr_2017"     
  # [7] "dr_2018"      "dr_2019"      "dr_2020"      "coords.x1"    "coords.x2"    "geometry"

  hfc_pop_malaria_sf_trim <- hfc_pop_malaria_sf %>% 
    dplyr::select(-c(pop_estimate, coords.x1, coords.x2))
 
  # Reorder columns by position
  hfc_malaria_pop_sf <- hfc_pop_malaria_sf_trim[, c(4, 3, 1, 2, 5, 6, 7, 8, 9)]

  return(out = hfc_malaria_pop_sf)

}

# Invoking the function 
# 2017 data -------------------------------------------------------------------------------
hfc_1km_2017_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run1k_2017)
hfc_2km_2017_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run2k_2017)
hfc_3km_2017_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run3k_2017)

# 2018 data -------------------------------------------------------------------------------
hfc_1km_2018_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run1k_2018)
hfc_2km_2018_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run2k_2018)
hfc_3km_2018_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run3k_2018)

# 2019 data -------------------------------------------------------------------------------
hfc_1km_2019_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run1k_2019) 
hfc_2km_2019_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run2k_2019)
hfc_3km_2019_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run3k_2019)

# 20 20 data ------------------------------------------------------------------------------
hfc_1km_2020_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run1k_2020)
hfc_2km_2020_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run2k_2020)
hfc_3km_2020_sf <- organize(malaria_data = health_facility_aggr_sf, pop_data = run3k_2020)

# Check if merging and tidying worked
# Create a user-defined function that maps the merged sf objects
malaria_map <- function(df, year = NA, title, legend.title = NA){
  # dry season malaria cases map
  # df: sf objects from 'organize' function
  # vname: variable name (as character, in qoutes)
  # title: map title in quotes
  # legend.title: legend title in qoutes
  # returns:
  #   a tmap-element (plots a map)
  tm_shape(df)+
    tm_fill(col = year, palette = "Oranges", n = 5, title = legend.title,
            breaks = c(400, 4000, 10000, 16000, 20000, 30000 ))+
    tm_borders("burlywood")+
    tm_layout(legend.position = c(0.6, "bottom"),
              legend.text.size = 0.6,
              legend.title.size = 0.8,
              title.size = .3,
              frame = FALSE)+
     tm_credits(title, position = c(0.2, 0.8), size = .9)+
    tm_view(view.legend.position = c("right", "bottom"))
}

dry_season_malaria_2017 <- malaria_map(hfc_1km_2017_sf, year = "dr_2017", title = "2017", 
                                       legend.title = "2017 malaria cases")

dry_season_malaria_2018 <- malaria_map(hfc_1km_2018_sf, year = "dr_2018", title = "2018",
                                       legend.title = "2018 malaria cases")

dry_season_malaria_2019 <- malaria_map(hfc_1km_2019_sf, year = "dr_2019", title = "2019",
                                       legend.title = "2019 malaria cases")

dry_season_malaria_2020 <- malaria_map(hfc_1km_2020_sf, year = "dr_2020", title = "2020",
                                       legend.title = "2020 malaria cases")

tmap::tmap_arrange(dry_season_malaria_2017, dry_season_malaria_2018,
                   dry_season_malaria_2019, dry_season_malaria_2020, ncol = 2)

# Rename population columns ----------------------------------------------------------------
hfc_1km_2017_sf <-  hfc_1km_2017_sf %>% 
  dplyr::rename(pop_1km_2017 = pop_1km)

hfc_2km_2017_sf <- hfc_2km_2017_sf %>% 
  dplyr::rename(pop_2km_2017 = pop_2km)

hfc_3km_2017_sf <- hfc_3km_2017_sf %>% 
  dplyr::rename(pop_3km_2017 = pop_3km)

hfc_1km_2018_sf <- hfc_1km_2018_sf %>% 
  dplyr::rename(pop_1km_2018 = pop_1km)

hfc_2km_2018_sf <- hfc_2km_2018_sf %>% 
  dplyr::rename(pop_2km_2018 = pop_2km)

hfc_3km_2018_sf <- hfc_3km_2018_sf %>% 
  dplyr::rename(pop_3km_2018 = pop_3km)

hfc_1km_2019_sf <- hfc_1km_2019_sf %>% 
  dplyr::rename(pop_1km_2019 = pop_1km)

hfc_2km_2019_sf <- hfc_2km_2019_sf %>% 
  dplyr::rename(pop_2km_2019 = pop_2km)

hfc_3km_2019_sf <- hfc_3km_2019_sf %>% 
  dplyr::rename(pop_3km_2019 = pop_3km)

hfc_1km_2020_sf <- hfc_1km_2020_sf %>% 
  dplyr::rename(pop_1km_2020 = pop_1km)

hfc_2km_2020_sf <- hfc_2km_2020_sf %>% 
  dplyr::rename(pop_2km_2020 = pop_2km)

hfc_3km_2020_sf <- hfc_3km_2020_sf %>% 
  dplyr::rename(pop_3km_2020 = pop_3km)

# Save the sf polygons ---------------------------------------------------------------------
# sf::st_write(hfc_1km_2017_sf, "data/hfc_1km_2017.shp")
# sf::st_write(hfc_2km_2017_sf, "data/hfc_2km_2017.shp")
# sf::st_write(hfc_3km_2017_sf, "data/hfc_3km_2017.shp")
# 
# sf::st_write(hfc_1km_2018_sf, "data/hfc_1km_2018.shp")
# sf::st_write(hfc_2km_2018_sf, "data/hfc_2km_2018.shp")
# sf::st_write(hfc_3km_2018_sf, "data/hfc_3km_2018.shp")
# 
# sf::st_write(hfc_1km_2019_sf, "data/hfc_1km_2019.shp")
# sf::st_write(hfc_2km_2019_sf, "data/hfc_2km_2019.shp")
# sf::st_write(hfc_3km_2019_sf, "data/hfc_3km_2019.shp")
# 
# sf::st_write(hfc_1km_2020_sf, "data/hfc_1km_2020.shp")
# sf::st_write(hfc_2km_2020_sf, "data/hfc_2km_2020.shp")
# sf::st_write(hfc_3km_2020_sf, "data/hfc_3km_2020.shp")




```

### Box plot of Kasungu dry season malaria cases from 2017 to 2020

```{r, message=FALSE, warning=FALSE, fig.width=8, fig.height=6, fig.cap= 'Fig. 8: Dry season malaria cases from 2017 - 2020 in Kasungu'}
dry_season_malaria <- as(hfc_1km_2017_sf, "Spatial")

ggplot2::ggplot(reshape2::melt(dry_season_malaria@data[, c("dr_2017", "dr_2018", "dr_2019", "dr_2020")]), 
  aes(variable, value)) +
  geom_boxplot() +
  xlab("Years") +
  ylab("Malaria cases") +
  theme_classic() 

```

### Calculate the expected number of malaria cases in health facility catchments

Now, we combine all the dataframes with estimated population and malaria cases into one dataframe `kasungu_model_df`, and new columns (`totalMalaria_year`, `totalPop_year`, `malariaProp_year`, and `expectedMalaria_year`) are then added. The aim is to determine the standardised mortality/morbidity ratio (SMR). SMR compares the risk of morbidity/mortality in a population of interest with that of a standard population. In this case, interest in understanding whether the number of dry season malaria cases in each health facility catchment are greater than we would expect given the rate of malaria in the whole of Kasungu district.
```{r, message=FALSE, warning=FALSE}

# 2017 dataframes --------------------------------------------------------------
hfc_1km_2017_df <- hfc_1km_2017_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(Names, FID, pop_1km_2017,
                                       dr_2017, dr_2018, dr_2019, dr_2020, geometry)
 
hfc_2km_2017_df <- hfc_2km_2017_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_2km_2017)

hfc_3km_2017_df <- hfc_3km_2017_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_3km_2017)

# 2018 dataframes --------------------------------------------------------------
hfc_1km_2018_df <- hfc_1km_2018_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_1km_2018)

hfc_2km_2018_df <- hfc_2km_2018_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_2km_2018)

hfc_3km_2018_df <- hfc_3km_2018_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_3km_2018)

# 2019 dataframes --------------------------------------------------------------
hfc_1km_2019_df <- hfc_1km_2019_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_1km_2019)

hfc_2km_2019_df <- hfc_2km_2019_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_2km_2019)

hfc_3km_2019_df <- hfc_3km_2019_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_3km_2019)

# 2020 dataframes --------------------------------------------------------------
hfc_1km_2020_df <- hfc_1km_2020_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_1km_2020)

hfc_2km_2020_df <- hfc_2km_2020_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_2km_2020)

hfc_3km_2020_df <- hfc_3km_2020_sf %>% unclass %>% 
  dplyr::as_tibble() %>% dplyr::select(FID, pop_3km_2020)

# Bind the dataframes and create new columns containing the total number of malaria
# cases (totalMalaria_year) throughout the whole district for each year, 
# total population of the whole district (totalPop_year) for each year, and 
# expected number of malaria cases (expectedMalaria_year) in each catchment,
# which is calculated by dividing totalMalaria_year with totalPop_year and multiplied
# by the number of people in each catchment
# 
kasungu_model_df <- cbind(hfc_1km_2017_df, hfc_2km_2017_df, hfc_3km_2017_df,
                          hfc_1km_2018_df, hfc_2km_2018_df, hfc_3km_2018_df,
                          hfc_1km_2019_df, hfc_2km_2019_df, hfc_3km_2019_df,
                          hfc_1km_2020_df, hfc_2km_2020_df, hfc_3km_2020_df) %>% 
  dplyr::select(-FID) %>%
  dplyr::mutate(totalMalaria_2017 = sum(dr_2017),
                totalMalaria_2018 = sum(dr_2018),
                totalMalaria_2019 = sum(dr_2019),
                totalMalaria_2020 = sum(dr_2020)) %>% 
  dplyr::mutate(totalPop_1km_2017 = round(sum(pop_1km_2017, na.rm = TRUE)),
                totalPop_2km_2017 = round(sum(pop_2km_2017, na.rm = TRUE)),
                totalPop_3km_2017 = round(sum(pop_3km_2017, na.rm = TRUE)),
                totalPop_1km_2018 = round(sum(pop_1km_2018, na.rm = TRUE)),
                totalPop_2km_2018 = round(sum(pop_2km_2018, na.rm = TRUE)),
                totalPop_3km_2018 = round(sum(pop_3km_2018, na.rm = TRUE)),
                totalPop_1km_2019 = round(sum(pop_1km_2019, na.rm = TRUE)),
                totalPop_2km_2019 = round(sum(pop_2km_2019, na.rm = TRUE)),
                totalPop_3km_2019 = round(sum(pop_3km_2019, na.rm = TRUE)),
                totalPop_1km_2020 = round(sum(pop_1km_2020, na.rm = TRUE)),
                totalPop_2km_2020 = round(sum(pop_2km_2020, na.rm = TRUE)),
                totalPop_3km_2020 = round(sum(pop_3km_2020, na.rm = TRUE))) %>% 
  dplyr::mutate(malariaProp_1km_2017 = round(totalMalaria_2017/totalPop_1km_2017, 1),
                malariaProp_2km_2017 = round(totalMalaria_2017/totalPop_2km_2017, 1),
                malariaProp_3km_2017 = round(totalMalaria_2017/totalPop_3km_2017, 1),
                malariaProp_1km_2018 = round(totalMalaria_2018/totalPop_1km_2018, 1),
                malariaProp_2km_2018 = round(totalMalaria_2018/totalPop_2km_2018, 1),
                malariaProp_3km_2018 = round(totalMalaria_2018/totalPop_3km_2018, 1),
                malariaProp_1km_2019 = round(totalMalaria_2019/totalPop_1km_2019, 1),
                malariaProp_2km_2019 = round(totalMalaria_2019/totalPop_2km_2019, 1),
                malariaProp_3km_2019 = round(totalMalaria_2019/totalPop_3km_2019, 1),
                malariaProp_1km_2020 = round(totalMalaria_2020/totalPop_1km_2020, 1),
                malariaProp_2km_2020 = round(totalMalaria_2020/totalPop_2km_2020, 1),
                malariaProp_3km_2020 = round(totalMalaria_2020/totalPop_3km_2020, 1)) %>% 
  dplyr::rowwise() %>%
  dplyr::mutate(expectedMalaria_1km_2017 = round(malariaProp_1km_2017*pop_1km_2017),
                expectedMalaria_2km_2017 = round(malariaProp_2km_2017*pop_2km_2017),
                expectedMalaria_3km_2017 = round(malariaProp_3km_2017*pop_3km_2017),
                expectedMalaria_1km_2018 = round(malariaProp_1km_2018*pop_1km_2018),
                expectedMalaria_2km_2018 = round(malariaProp_2km_2018*pop_2km_2018),
                expectedMalaria_3km_2018 = round(malariaProp_3km_2018*pop_3km_2018),
                expectedMalaria_1km_2019 = round(malariaProp_1km_2019*pop_1km_2019),
                expectedMalaria_2km_2019 = round(malariaProp_2km_2019*pop_2km_2019),
                expectedMalaria_3km_2019 = round(malariaProp_3km_2019*pop_3km_2019),
                expectedMalaria_1km_2020 = round(malariaProp_1km_2020*pop_1km_2020),
                expectedMalaria_2km_2020 = round(malariaProp_2km_2020*pop_2km_2020),
                expectedMalaria_3km_2020 = round(malariaProp_3km_2020*pop_3km_2020))

# Take a glimpse at the data
table <- kasungu_model_df %>%
  dplyr::select(Names, observed_2017 = `dr_2017`, observed_2018 = `dr_2018`, 
                observed_2019 = `dr_2019`, observed_2020 = `dr_2020`, 
                expectedMalaria_1km_2017, expectedMalaria_2km_2017, expectedMalaria_3km_2017, 
                expectedMalaria_1km_2018, expectedMalaria_2km_2018, expectedMalaria_3km_2018, 
                expectedMalaria_1km_2019, expectedMalaria_2km_2019, expectedMalaria_3km_2019, 
                expectedMalaria_1km_2020, expectedMalaria_2km_2020, expectedMalaria_3km_2020) %>% 
  kable %>%
  kableExtra::kable_styling(full_width = FALSE)

table

```



### Save `Kasungu model `data

```{r, message=FALSE, warning=FALSE}

write.csv(kasungu_model_df, file = "data/Kasungu_model_data_2017_2020.csv")


```

### Model fitting

We can then model the observed outcomes using `Poisson regression` with an offset of the log of the expected counts `expectedMalaria`. `Poisson regression` framework has been used as it is suitable for modeling count outcomes. 

```{r}
# 2017 -----------------------------------------------------------------------------------
model_1km_2017 <- glm(dr_2017~malariaProp_1km_2017, offset = log(expectedMalaria_1km_2017),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)
# alias(model_1km_2017)
# sjPlot::tab_model(model_1km_2017)
summary(model_1km_2017)

model_2km_2017 <- glm(dr_2017~malariaProp_2km_2017, offset = log(expectedMalaria_2km_2017),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_2km_2017)

model_3km_2017 <- glm(dr_2017~malariaProp_3km_2017, offset = log(expectedMalaria_3km_2017),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_3km_2017)

# 2018 -----------------------------------------------------------------------------------
model_1km_2018 <- glm(dr_2018~malariaProp_1km_2018, offset = log(expectedMalaria_1km_2018),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_1km_2018)

model_2km_2018 <- glm(dr_2018~malariaProp_2km_2018, offset = log(expectedMalaria_2km_2018),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_2km_2018)

model_3km_2018 <- glm(dr_2018~malariaProp_3km_2018, offset = log(expectedMalaria_3km_2018),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_3km_2018)

# 2019 ----------------------------------------------------------------------------------
model_1km_2019 <- glm(dr_2019~malariaProp_1km_2019, offset = log(expectedMalaria_1km_2019),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_1km_2019)

model_2km_2019 <- glm(dr_2019~malariaProp_2km_2019, offset = log(expectedMalaria_2km_2019),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_2km_2019)

model_3km_2019 <- glm(dr_2019~malariaProp_3km_2019, offset = log(expectedMalaria_3km_2019),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_3km_2019)

# 2020 ----------------------------------------------------------------------------------
model_1km_2020 <- glm(dr_2020~malariaProp_1km_2020, offset = log(expectedMalaria_1km_2020),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_1km_2020)

model_2km_2020 <- glm(dr_2020~malariaProp_2km_2020, offset = log(expectedMalaria_2km_2020),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_2km_2020)

model_3km_2020 <- glm(dr_2020~malariaProp_3km_2020, offset = log(expectedMalaria_3km_2020),
                      data = kasungu_model_df, family = 'poisson', na.action = na.omit)

summary(model_3km_2020)



```


### Scatter plot
```{r}
# 2017 model ------------------------------------------------------------------
ggplot() + geom_point(aes(model_1km_2019$fitted.values, kasungu_model_df$dr_2019))


```


### Create maps
```{r}

pop_malaria_2017_2020 <- raster::shapefile(here::here("data/Kasungu_pop_malaria_2017_2020merge"))

pop_malaria_2017_2020$fitted_1km2019 <- round(model_1km_2019$fitted.values)

mapview::mapview(pop_malaria_2019_2020, zcol = "fitted_1km2019")


```






